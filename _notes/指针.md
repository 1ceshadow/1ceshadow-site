[[C语言学习]]

C语言中的指针是一种非常强大且核心的特性，它允许程序直接访问和操作内存地址。指针变量存储的是变量的内存地址，而不是变量的值本身。下面是一些关于C语言指针的基本用法和概念的讲解：

### 1. 指针的定义

指针的定义使用星号（\*）作为前缀。例如，定义一个指向整数的指针`intPtr`可以这样写：

```c
int *intPtr;
```

这里，`intPtr`是一个指针变量，它可以存储一个整数的内存地址。

### 2. 指针的赋值

指针可以通过两种方式赋值：

- 直接赋值地址（通常不推荐，因为直接操作内存地址可能导致不可预测的行为）：

```c
int a = 10;
intPtr = &a; // &a是变量a的地址
```

- 赋值另一个指针的值（即地址）：

```c
int *intPtr2 = intPtr; // 现在intPtr2也指向了a的地址
```

### 3. 指针的解引用

解引用指针意味着访问指针所指向地址的值。使用星号（\*）作为前缀来实现：

```c
printf("%d\n", *intPtr); // 输出10
```

### 4. 指针的算术运算

指针可以进行简单的算术运算，如递增（++）和递减（--），这些操作实际上是在修改指针所指向的地址。指针的算术运算以指针所指向类型的大小为单位进行：

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;
ptr++; // ptr现在指向arr[1]
```

### 5. 指针与数组

在C语言中，数组名通常被视为指向数组首元素的指针。因此，可以通过指针来访问数组元素：

```c
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr;
printf("%d\n", *(ptr + 2)); // 输出3
```

### 6. 指针与函数

指针可以作为函数的参数和返回值，这在处理大型数据结构或需要修改多个变量时非常有用：

```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int main() {
    int x = 10, y = 20;
    swap(&x, &y);
    printf("%d %d\n", x, y); // 输出20 10
    return 0;
}
```

### 7. 注意事项

- 指针在解引用前必须被正确初始化，否则可能会导致未定义行为。
- 指针运算时要注意不要越界，以免访问非法的内存地址。
- 动态分配的内存（如使用`malloc`或`calloc`）在使用完毕后应该释放（使用`free`），避免内存泄漏。
### 8.下面两个例子

+ 实现一个字符串逆序的简单函数。
	```C
	void f( char *p ){
	    char *start = p;
	    char *end = p;
    
	    while (*end != '\0')
	        end++;

	    end--;//此时end指向'\0',所以退一位
	    while (start < end){
	        char temp = *start;
	        *start = *end;
	        *end = temp;

	        start++;
	        end--;
	    }
	}
	```

+ 将两个字符串连接起来。
	```C
		char *str_cat(char *s, char *t)
		{
	    char *original_s = s; // 保存原始目标字符串的首地址
    
	    // 找到目标字符串的末尾
	    while (*s != '\0') {
	        s++;
	    }
    
	    // 将源字符串复制到目标字符串的末尾
	    while (*t != '\0') {
	        *s = *t;
	        s++;
	        t++;
	    }
    
	    *s = '\0';
    
	    return original_s; 
		}
	```

---
### 指针分配内存

常见的写法有：`int* ptr = malloc(size)`和 `int* ptr = (int *)malloc(size)`   
后者用了一个`(int *)` ，这让初学的我非常困惑，前面不是已经声明它是`int*` 了吗？  

`(int *)` 是显式的类型转化，`malloc` 的函数原型如下：
```C
void *malloc(size_t size);
```
`void *` 是一种通用指针类型，它可以指向任意类型的数据。这意味着 `void *` 指针可以接收任何类型的指针赋值，也可以赋值给其他类型的指针，但在进行某些操作（如解引用）之前，通常需要将其转换为具体的数据类型指针。  

在语句 `int *ptr = (int *)malloc(size);` 中，`(int *)` 的作用是将 `malloc` 函数返回的 `void *` 类型指针强制转换为 `int *` 类型指针。因为 `str` 是一个 `int *` 类型的指针变量，用于指向 `int` 类型的数据，所以需要将 `malloc` 返回的通用指针转换为 `int *` 类型，以便将其赋值给 `ptr`。
#### 注意
- 在 C 语言中，将 `void *` 类型指针赋值给其他类型的指针时，编译器会自动进行隐式类型转换，因此 `(int *)` 强制类型转换在 C 语言里<font color="red">不是必须的</font>的，即可以写成 `int *ptr = malloc(size);`。
- 但在 C++ 中，不允许将 `void *` 类型指针隐式转换为其他类型的指针，必须使用强制类型转换，所以 `(int *)` <font color="green"> 在 C++ 中是必要的</font> 。