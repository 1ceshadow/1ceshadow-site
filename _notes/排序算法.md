---
title: 排序算法
date: 2025-02-26 20:13:17
feed: hide
---
[[C语言学习]] #CS50 

---
[比较算法可视化](https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html)

循环 or 递归

+ 选择排序*Selection sort*
	遍历出最大值，然后缩小范围，一直循环该过程

+ 冒泡排序*Bubble sort*
	依次比较相邻两项，选出最大值

+ 归并排序*merge sort*
	采用二分法，分别排好两边，再合并起来

*Selection sort*
```C
type array[len];
for (int i = 0; i < len; i++)
{
	int max = i;
	for (int j = i + 1; j < len; j++)
	{
		if (array[j] > array[max])
		{
			max = j;
		}
	}
	type temp = array[i];
	array[i] = array[max];
	array[max] = temp;
}
```


*Bubble sort*
```C
type array[len];
for (int i = 0; i < len; i++)
{
	for (int j = i; j < len - 1; j++)
	{
		if (array[j] < array[j + 1])
		{
			type temp = array[j];
			array[j] = array[j + 1];
			array[j + 1] = temp;
		}
	}
}
```

*Merge sort*
归并算法较复杂，但也较为高效
+ 递归法1：
```C
void merge_sort_recursive(int array[], int tmp[], int start, int end);

void merge_sort(int array[], int len) {
	int register[len];
	merge_sort_recursive(array, register, 0, len - 1);
}

void merge_sort_recursive(int array[], int tmp[], int start, int end) {
	if (start >= end) {
		return;
	}
	// 分
	int mid = (end - start) / 2;
	int Lstart = start, Lend = mid, Rstart = mid + 1, Rend = end;
	int Llen = mid - start + 1, Rlen = end - mid;

	merge_sort_recursive(array, tmp, Lstart, Lend);
	merge_sort_recursive(array, tmp, Rstart, Rend);

	// 合
	int k = start;
	while (Lstart <= Lend && Rstart <= Rend) {
		tmp[k++] = array[Lstart] < arrat[Rstart] ? array[Lstart++] : array[Rstart++];
	}
	while (Lstart <= Lend) {
		tmp[k++] = array[Lstart++];
	}
	while (Rstart <= Rend) {
		tmp[k++] = array[Rstart++];
	}
}
```
+ 递归法2：
```C
void merge()
```

